import java.util.regex.Pattern

/*
  Copyright 2019 Kakao Corp.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
apply plugin: "com.android.library"
apply plugin: "kotlin-android"
apply plugin: "kotlin-kapt"
apply plugin: "kotlin-parcelize"
apply plugin: "jacoco"
apply plugin: "maven-publish"
apply plugin: 'kotlinx-serialization'

jacoco {
    toolVersion = "0.8.12"
}

task sourcesJar(type: Jar) {
    def proguardFile = file('proguard-rules.pro')
    def consumerRulesFile = file('consumer-rules.pro')
    includeEmptyDirs = false
    archiveClassifier.set("sources")

    from {
        def isMinifyEnabled = shouldBeObfuscated(project.name)

        if (!isMinifyEnabled) {
            return android.sourceSets.main.java.srcDirs
        }

        def includes = []
        if (proguardFile.exists()) {
            includes.addAll(collectNonObfuscatedSources(proguardFile))
        }
        if (consumerRulesFile.exists()) {
            includes.addAll(collectNonObfuscatedSources(consumerRulesFile))
        }

        def fileTrees = android.sourceSets.main.java.srcDirs.collect { dir ->
            fileTree(dir: dir, includes: includes)
        }
        return fileTrees
    }
}

android {
    compileSdkVersion SdkVersions.compileSdkVersion

    defaultConfig {
        minSdkVersion SdkVersions.minSdkVersion
        targetSdkVersion SdkVersions.targetSdkVersion
        buildConfigField("String", "VERSION_NAME", "\"${SdkVersions.version}\"")

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        if (shouldBeObfuscated(name)) {
            debug {
                println(name + " minifyEnabled false")
                // verification-test task를 수행할 때 jacoco에서 간헐적으로 error가 발생해서 임시로 주석 처리
//                 testCoverageEnabled true
                minifyEnabled false
            }
            release {
                println(name + " minifyEnabled true")
                minifyEnabled true
                proguardFiles getDefaultProguardFile("proguard-android-optimize.txt")
                proguardFile 'proguard-rules.pro'
            }
        } else {
            debug {
                // verification-test task를 수행할 때 jacoco에서 간헐적으로 error가 발생해서 임시로 주석 처리
//                testCoverageEnabled true
                minifyEnabled false
            }
            release {
                minifyEnabled false
                //proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            }
        }
    }

    testOptions {
        unitTests {
            includeAndroidResources = true
        }
        unitTests.all {
            jacoco {
                includeNoLocationClasses = true
                excludes = ['jdk.internal.*'] // jdk11 호환 이슈가 있음
            }

            // https://kakao.agit.in/g/300068661/wall/412240460#comment_panel_412248122
            systemProperty("robolectric.dependency.proxy.host", "proxy.daumkakao.io")
            systemProperty("robolectric.dependency.proxy.port", 3128)
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    /// 테스트 데이터 디렉토리 지정
    sourceSets {
        test {
            resources.srcDirs += ['../kakao-sdk-test-data', '../open/kakao-sdk-test-data']
        }
        androidTest {
            resources.srcDirs += ['../kakao-sdk-test-data', '../open/kakao-sdk-test-data']
        }
    }

    tasks.withType(Test) {
        useJUnitPlatform()
    }

    // parallel 빌드를 안하면 ./gradlew test publish dokka zipProject 등 순서대로 실행하면 된다.
    // task 의존성 설정 (testReleaseUnitTest -> assembleRelease, dokka -> zipProject)
    libraryVariants.all { variant ->
        if (variant.buildType.name == "debug") return
        rootProject.getTasksByName("zipProject", false).forEach {
            it.dependsOn(assembleRelease)
        }

        rootProject.getTasksByName("dokka", false).forEach {
            it.mustRunAfter(testReleaseUnitTest) // dokka 문서 생성 전에 unit test 를 돌림
        }
        assembleRelease.dependsOn(testReleaseUnitTest) // release 빌드 전에는 release unit test 를 무조건 돌린다.
    }
}

publishing {
    repositories {
        maven {
            if (SdkVersions.version.endsWith("-SNAPSHOT")) {
                url project.hasProperty("NEXUS_SNAPSHOT_REPOSITORY_URL") ? NEXUS_SNAPSHOT_REPOSITORY_URL : new GradleException()
            } else {
                url project.hasProperty("NEXUS_RELEASE_REPOSITORY_URL") ? NEXUS_RELEASE_REPOSITORY_URL : new GradleException()
            }

            if (project.hasProperty("NEXUS_USERNAME") && project.hasProperty("NEXUS_PASSWORD")) {
                credentials {
                    username NEXUS_USERNAME
                    password NEXUS_PASSWORD
                }
            }
        }
    }
    android.libraryVariants.all { variant ->
        if (variant.buildType.name == 'debug') return
        version = "${SdkVersions.version}"
        publications {
            "${variant.name}"(MavenPublication) {
                groupId Publish.groupId
                version version
                artifactId "v2-${project.name}"

                artifact(variant.packageLibraryProvider.get().archivePath) {
                    builtBy variant.assembleProvider // assembleRelease 에 의존성 설정
                }

                artifact sourcesJar

                pom.withXml {
                    def dependenciesNode = asNode().appendNode('dependencies')
                    //Iterate over the compile dependencies (we don't want the test ones), adding a <dependency> node for each
                    variant.compileConfiguration.allDependencies.each {
                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        if (it.hasProperty('dependencyProject')) {
                            // kakao sdk modules
                            dependencyNode.appendNode('groupId', Publish.groupId)
                            dependencyNode.appendNode('artifactId', "v2-${it.name}")
                            dependencyNode.appendNode('version', version)
                            dependencyNode.appendNode('type', 'aar')
                        } else {
                            // external dependencies
                            dependencyNode.appendNode('groupId', it.group)
                            dependencyNode.appendNode('artifactId', it.name)
                            dependencyNode.appendNode('version', it.version)
                        }
                    }

                    def licenses = asNode().appendNode('licenses')
                    def license = licenses.appendNode('license')
                    license.appendNode('name', 'The Apache Software License, Version 2.0')
                    license.appendNode('url', 'http://www.apache.org/licenses/LICENSE-2.0.txt')
                    license.appendNode('distribution', 'repo')
                }
            }
        }
    }
}

//task jacocoTestReport(type: JacocoReport, dependsOn: "testDebugUnitTest") {
//    group "Reporting"
//    description "Generate Jacoco coverage reports."
//
//    reports {
//        html.enabled = true
//    }
//
//    def fileFilter = ["**/R.class", "**/R\$*.class", "**/BuildConfig.*", "**/Manifest*.*", "**/*Test*.*", "android/**/*.*"]
//    def execution = fileTree(dir: project.buildDir,
//            includes: ["jacoco/testDebugUnitTest.exec",
//                       "outputs/code_coverage/debugAndroidTest/connected/**/*.ec"])
//
//    afterEvaluate {
//        def javaClasses = fileTree(dir: compileDebugJavaWithJavac.destinationDir, excludes: fileFilter)
//        def kotlinClasses = fileTree(dir: compileDebugKotlin.destinationDir, excludes: fileFilter)
//        classDirectories.setFrom(files(javaClasses, kotlinClasses))
//    }
//    executionData.setFrom(files(execution))
//}

static def shouldBeObfuscated(name) {
    (name.contains("friend") || name.contains("cert")) && !name.contains("rx")
}

static def collectNonObfuscatedSources(file) {
    def includes = []
    def keepPatterns = [
            Pattern.compile(/-keep(?:names|classmembers|classeswithmembers|classmembernames|classeswithmembernames)?\s+class\s+([\w.$*]+).*/)
    ]

    file.eachLine { line ->
        if (line.trim().startsWith('#')) return

        for (pattern in keepPatterns) {
            def matcher = pattern.matcher(line)
            if (matcher.matches()) {
                def className = matcher.group(1)

                if (!className.contains("*")) {
                    includes.add(className.replace('.', '/') + ".java")
                    includes.add(className.replace('.', '/') + ".kt")
                    break
                }

                if (className.contains("*")) {
                    if (className.endsWith(".*")) {
                        def packagePath = className.substring(0, className.length() - 2).replace('.', '/')
                        includes.add("${packagePath}/**/*.java")
                        includes.add("${packagePath}/**/*.kt")
                        break
                    }

                    // 와일드카드가 중간에 있는 경우 (ex - com.*.sdk)
                    if (className.contains(".*")) {
                        def parts = className.split("\\.")
                        def path = ""
                        for (int i = 0; i < parts.length; i++) {
                            if (parts[i] == "*") {
                                path += "**/"
                            } else {
                                path += parts[i] + "/"
                            }
                        }
                        includes.add("${path}*.java")
                        includes.add("${path}*.kt")
                        break
                    }

                    // 클래스 이름 자체에 와일드카드가 있는 경우 (ex - *Activity)
                    def normalizedName = className.replace('.', '/').replace("*", "*")
                    includes.add("${normalizedName}.java")
                    includes.add("${normalizedName}.kt")
                    break
                }
            }
        }
    }

    return includes
}
